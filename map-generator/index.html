<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <meta name='og:image' content='http://pfrosa.github.io/project-thumbnails/map-generator.png'>
    <title>Map Generator</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <button id="open-config">
        <a href="#config"><img src="./cog-wheel.png"></a>
    </button>
    <section class="controls" id="config">
        <label for="n-players">Num. de Jogadores:</label>
        <select name="n-players" id="n-players">
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4" selected>4</option>
            <option value="5">5</option>
            <option value="6">6</option>
        </select>
        <label for="n-players">Biomas:</label>
        <div class="bioms-wrapper">
            <div class="biom">
                <label for="">Tundra</label>
                <input type="checkbox" name="" id="" value="Tundra">
            </div>
            <div class="biom">
                <label for="">Savana</label>
                <input type="checkbox" name="" id="" value="Savana">
            </div>
            <div class="biom">
                <label for="">Costeiro (Praia/Costa)</label>
                <input type="checkbox" name="" id="" value="Costeiro">
            </div>
            <div class="biom">
                <label for="">Urbano/Rural</label>
                <input type="checkbox" name="" id="" value="Urbano">
            </div>
            <div class="biom">
                <label for="">Floresta</label>
                <input type="checkbox" name="" id="" value="Floresta">
            </div>
            <div class="biom">
                <label for="">Montanhoso</label>
                <input type="checkbox" name="" id="" value="Montanhoso">
            </div>
            <div class="biom">
                <label for="">Desértico</label>
                <input type="checkbox" name="" id="" value="Desértico">
            </div>
            <div class="biom">
                <label for="">Campos</label>
                <input type="checkbox" name="" id="" value="Campos">
            </div>
        </div>
        <label for="map-size">Tamanho do Mapa:</label>
        <select name="map-size" id="map-size">
            <option value="small">Pequeno</option>
            <option value="medium" selected>Médio</option>
            <option value="big" >Grande</option>
        </select>
        <button id="regen"> re-generate </button>
        <a href="#map">
            <button> close </button>
        </a>
    </section>
    <main class="map">

    </main>
</body>

<script>
    //@TODO:
    //fix colors on bioms, add player count to mather, add selected bioms to matter
    //get special biom rule for coast and beaches
    const _MAP_SIZES = {
        big: {
            MAX_WIDTH: 12,
            MIDDLEROWS: 23,
            SPREAD: 4,
        },
        medium: {
            MAX_WIDTH: 10,
            MIDDLEROWS: 19, 
            SPREAD: 3,
        },
        small: {
            MAX_WIDTH: 8,
            MIDDLEROWS: 15,
            SPREAD: 2,
        }
    }


    //default to big map size
    const CONFIG = {
        NUM_PLAYERS: 4,
        MAX_WIDTH: 12,
        MIDDLEROWS: 17,
        SPREAD: 4,
    };

    const STATE = {
        rows: [],
        flatHexes: [],
        flatIndex: 0
    };
    // agua eh na borda de alguns biomas especificos, praia e costeiro so
    const BIOMS = [
        {
            name: 'montain',
            backgroundColor: 'lightGray',
            backgroundImage: 'url(montain.svg)'
        },
        {
            name:"Tundra",
            backgroundColor: 'cyan'
            
        },
        {
            name:"Savana",
            backgroundColor: 'lightyellow'
            
        },
        {
            name:"Costeiro (Praia/Costa)",
            backgroundColor: 'red'
            
        },
        {
            name:"Urbano/Rural",
            backgroundColor: 'gray'
            
        },
        {
            name:"Floresta (Densa/ Aberta/ Montanhosa/ Temperada/ Tropical)",
            backgroundColor: 'olive'
            
        },
        {
            name:"Desértico",
            backgroundColor: 'pink'
            
        },
        {
            name:"Campos",
            backgroundColor: 'green'
            
        },

    ];

    const SEED = Math.random();
    Math.seedrandom(SEED);
    // Math.seedrandom(0.41342047817838035);
    const mapElement = document.body.querySelector('.map');
    const reGen = document.body.querySelector('#regen');
    const mapSize = document.body.querySelector('#map-size');

    // @TODO get diff solution to this, a map solve it;
    const createHexObject = (row, pos) => ({
        row,
        pos,
        bgColor: false,
        opacity: 1,
        flatIndex: STATE.flatIndex++,
        text: `${row}-${pos}`,
        biomIndex: null,
    });

    const createHex = (content = {}) => {
        const hexElement = document.createElement('div');
        hexElement.style.backgroundColor =  BIOMS[content.biomIndex].backgroundColor || content.bgColor;
        hexElement.style.opacity = content.opacity;
        hexElement.dataset.dist = content.dist || 0;

        hexElement.innerText = content.text;
        hexElement.style.backgroundImage = content.showImage ? BIOMS[content.biomIndex].backgroundImage || 'none' : 'none';
        hexElement.classList.add('hex');
        // hexElement.addEventListener('click', () => hexElement.style.opacity = 1);
        content.htmlElement = hexElement;
        return hexElement;
    }

    const createRow = (row) => {
        const rowElement = document.createElement('div');
        rowElement.append(...row.map(createHex))
        rowElement.classList.add('row');
        return rowElement;
    }

    const generateView = (showNormalized = false) => {
     
        Object.assign(CONFIG, _MAP_SIZES[mapSize.value]);

        STATE.flatIndex = 0;

        STATE.rows = [
            ...Array(CONFIG.MAX_WIDTH - 1).fill(true).map((_, i) => Array(i + 1).fill(i).map(createHexObject)),
            ...Array(CONFIG.MIDDLEROWS).fill(true).map((_, i) => Array(CONFIG.MAX_WIDTH - i % 2).fill(i + CONFIG.MAX_WIDTH - 1).map(createHexObject)),
            ...Array(CONFIG.MAX_WIDTH - 1).fill(true).map((_, i) => Array(CONFIG.MAX_WIDTH - (i + 1)).fill(i + CONFIG.MIDDLEROWS + CONFIG.MAX_WIDTH - 1).map(createHexObject)),
        ];

        STATE.flatHexes = STATE.rows.flat();

        const selectedBiomsIndex = Array(CONFIG.NUM_PLAYERS).fill(1).map((_,i) => i);
        const biomCountProxyHandler = {
            get(target, p) {
                if (!target[p]) {
                    target[p] = 0;
                }
                return target[p];
            }
        };
        const biomCount = new Proxy({}, biomCountProxyHandler);



        const spread = (hex, i, inplace = false) => {
            const spreadDistN = getNeighborHexesV3(hex, CONFIG.SPREAD, true);
            const randomCenterHex = spreadDistN[getRandomInt(spreadDistN.length)];
            const spread = getSpreadV3(inplace ? hex : randomCenterHex, CONFIG.SPREAD, true);
            spread.forEach(neighbor => {
                biomCount[BIOMS[selectedBiomsIndex[i]].name]++;
                if (!neighbor.bgColor) {
                    neighbor.biomIndex = selectedBiomsIndex[i];
                    neighbor.dist = neighbor.depth;
                }
            })
            // rows.at(randomCenterHex.row)[randomCenterHex.pos].opacity = 0.3;
        }

        const randomHex = [
        ];

        STATE.flatHexes.forEach(hex => hex.bgColor = false)

        Array(CONFIG.NUM_PLAYERS).fill(true).forEach(_ => {
            const mapEdges = getNeighborHexesV3({ row: CONFIG.MIDDLEROWS-1, pos: (CONFIG.MAX_WIDTH-2 )/2}, CONFIG.MAX_WIDTH-1, true); //THI NEED TO ADAPT TO SIZE
            let randomNumber = getRandomInt(STATE.flatHexes.length);
            let neighbors = getSpreadV3(STATE.flatHexes[randomNumber], CONFIG.SPREAD + 1)
            let neighborsIndex = neighbors.map(n => n.flatIndex);
            //avoiding borders on startgin bioms
            const borderFlatIndex = mapEdges.map(border => {
                // rows[border.row][border.pos].bgColor ="orange"
                return STATE.rows[border.row][border.pos].flatIndex;
            });

            while (borderFlatIndex.includes(randomNumber) ||
                randomHex.includes(randomNumber) ||
                neighborsIndex.some(i => randomHex.includes(i))) {
                randomNumber = getRandomInt(STATE.flatHexes.length)
                neighbors = getSpreadV3(STATE.flatHexes[randomNumber], CONFIG.SPREAD + 1)
                neighborsIndex = neighbors.map(n => n.flatIndex);
            }
            randomHex.push(randomNumber);
        })

        console.log(randomHex);
        //i here should be biom

        //PAINT RANDOM HEX and spread
        randomHex.forEach((hexPos, i) => {
            const hex = STATE.flatHexes[hexPos];
            spread(hex, i, true);
            STATE.rows.at(hex.row)[hex.pos].biomIndex = selectedBiomsIndex[i];
            STATE.rows.at(hex.row)[hex.pos].dist = 0;
        })

        randomHex.reverse().forEach((hexPos, i) => {
            const hex = STATE.flatHexes[hexPos];
            spread(hex, 3 - i);
        })

        randomHex.reverse().forEach((hexPos, i) => {
            const hex = STATE.flatHexes[hexPos];
            spread(hex, i);
        })

        while (STATE.flatHexes.some(hex => hex.biomIndex == null)) {
            // break;
            STATE.flatHexes.filter(hex => hex.biomIndex == null)
                .forEach(hex => {
                    const neighbors = getSpreadV3(hex, 1);
                    const colorCount = neighbors.reduce((bioms, n) => {
                        if (n.biomIndex) bioms[n.biomIndex] += 1;
                        return bioms;
                    }, new Proxy({}, biomCountProxyHandler));
                    const majority = Object.keys(colorCount)
                        .reduce((biggest, current) =>
                            biggest = colorCount[current] > (colorCount[biggest] || 0) ? current : biggest, 0);

                    if (majority) {
                        hex.biomIndex = Number(majority);
                    }
                });
        }
        console.log(STATE.flatHexes);

        if (showNormalized) {
            const allNormalizedHexes = STATE.flatHexes
                .map(hex => {
                    const newHex = normalizePos(hex);
                    hex.text = `${newHex.row}-${newHex.column}`;
                    return newHex;
                })
        }


        STATE.flatHexes.forEach(hex => {
            const neighbors = getNeighborHexesV3(hex, 1, true).map(hex => STATE.rows[hex.row][hex.pos]);
            const isBorder = neighbors.some(n => n.biomIndex !== hex.biomIndex);
            hex.opacity = isBorder ? 0.7 : 1;
            hex.showImage = isBorder ? false : true;
        });

        const elementsOnMap = STATE.rows.map(createRow);
        mapElement.innerHTML = '';
        mapElement.append(...elementsOnMap);
    }

    const getRandomInt = (max) => Math.floor(Math.random() * max);

    const normalizePos = hex => {
        const distFromEdge = hex.row > (CONFIG.MIDDLEROWS + CONFIG.MAX_WIDTH - 3) ?
            hex.row - (CONFIG.MIDDLEROWS + CONFIG.MAX_WIDTH - 3) : CONFIG.MAX_WIDTH - hex.row
        return {
            ...hex,
            rowPair: hex.row + (hex.row % 2 !== 0 ? 1 : 0),
            column: (distFromEdge > 0 ? distFromEdge - 1 : 1) + hex.pos * 2 + (distFromEdge < 1 && hex.row % 2 != 0 ? -1 : 0),
        }
    };

    const getNeighborHexesV3 = (hex = { row: 0, pos: 0 }, distance = 1, borderOnly = false) => {
        //center is the 1 
        const normalizedHex = normalizePos(hex);
        const columns = 1 + distance * 2;
        const offsetsColumns = Array(columns).fill(true).map((_, i) => i - Math.floor(columns / 2))
        const offsetsRows = offsetsColumns
            .map((offset, i) =>
                Array(offsetsColumns.length - Math.abs(i - Math.floor(offsetsColumns.length / 2)))
                    .fill(true)
                    .map((_, i, x) =>
                        (
                            (i - Math.floor(x.length / 2))
                            + (x.length % 2 == 0 && i >= x.length / 2 ? 1 : 0)
                        ) * -2 + (x.length % 2 == 0 ? i >= x.length / 2 ? +1 : -1 : 0)));

        if (borderOnly) {
            offsetsRows.forEach((_, i, a) => _.forEach((_, j, b) => {
                if (i > 0 && j > 0 && i < a.length - 1 && j < b.length - 1) {
                    offsetsRows[i][j] = Infinity;
                }
            }))
        }


        const allNormalizedHexes = STATE.flatHexes
            .map(normalizePos)
            .reduce((arr, hex) => {
                if (!arr[hex.row]?.length) {
                    arr[hex.row] = new Array(CONFIG.MAX_WIDTH * 2 -1 ).fill();
                }
                arr[hex.row] = arr[hex.row].with(hex.column, hex);
                return arr;
            }, []);


        const hexes = offsetsColumns.map((oc, i) => {
            return offsetsRows[i].map(or => {
                const offsetObjectNormalized = {
                    oc,
                    or,
                    _row: normalizedHex.row + or,
                    _pos: normalizedHex.column + oc,
                };
                const actualHex = allNormalizedHexes[offsetObjectNormalized._row]?.[offsetObjectNormalized._pos];
                return actualHex;
            })
        });

        return hexes.flat().filter(_ => _);
    }

    const getSpreadV3 = (hex, depth = 1, setDepth = false) => {
        return Array(depth)
            .fill(true)
            .map((_, i) => getNeighborHexesV3(hex, i + 1, i > 0))
            .map((ditanceObjs, i) =>
                ditanceObjs.map(distanceObj => {
                    const { row, pos } = distanceObj;
                    const hex = STATE.rows[row]?.[pos];
                    if (setDepth && hex && !hex.depth) {
                        hex.depth = i + 1;
                    };
                    return hex;
                })
            )
            .flat()
    }


    generateView(false);
    reGen.addEventListener('click', generateView);
    //borda do bioma é onde os 6 vizinhos não são do mesmo bioma;
</script>

</html>